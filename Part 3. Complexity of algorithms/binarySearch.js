const data = [1, 3, 5, 7, 9, 11, 13, 55, 76, 79, 84, 99, 114, 142, 179, 223];

function binarySearch(sortedArr, value) {
  let firstIndex = 0;
  let middleIndex;
  let lastIndex = sortedArr.length - 1;

  let valueIndex = -1;
  let found = false;

  while (!found && firstIndex <= lastIndex) {
    middleIndex = Math.floor((firstIndex + lastIndex) / 2);

    if (sortedArr[middleIndex] === value) {
      found = true;
      valueIndex = middleIndex;
    } else if (sortedArr[middleIndex] > value) {
      lastIndex = middleIndex - 1;
    } else {
      firstIndex = middleIndex + 1;
    }
  }

  return valueIndex;
}

// тест-кейс, когда искомый элемент находится в начале массива:
console.log(binarySearch(data, 1)); // 0
// тест-кейс, когда искомый элемент находится в конце массива:
console.log(binarySearch(data, 223)); // 15
// тест-кейс, когда искомого элемента в массиве нет:
console.log(binarySearch(data, 333)); // -1

/* 
  Суть binarySearch: 
    1. находится индекс серединного элемента массива;
    2. сравнивается значение этого элемента с искомым значением;
    3. если значение серединного элемента совпадает с искомым значением - возвращаем его индекс;
    4. если значение серединного элемента больше искомого значения - работаем с левой частью массива и повторяем все пункты для нее;
    5. если значение серединного элемента меньше искомого значения - работаем с правой частью массива и повторяем все пункты для нее;
    И так до тех пор, пока не будет найден индекс искомого значения.

  Ответы на вопросы:
    1. Почему бинарный поиск нельзя применять к неотсортированному массиву?
      - Если массив не отсортирован, бинарный поиск может отбросить ту часть массива, 
        где реально лежит ответ, и вернуть -1, хотя элемент там есть.
    2. Какая асимптотическая сложность алгоритма по времени и почему это O(log n)?
      - На каждом шаге мы выкидываем половину оставшегося диапазона, следовательно, 
        общее число шагов растёт как логарифм от размера массива, то есть O(log n).
    3. Какая сложность по памяти?
      - Тут могу предположить, что так как функция binarySearch хранит внутри себя переменные с примитивными
        типами данных (number и boolean), цикл while внутри себя только переопределяет значения этих переменных
        и плюс функция принимает массив, значения которого только читает (не видоизменяя массив) - предполагаю, 
        что сложность по памяти: О(1). Если я ошибаюсь, поправьте меня, пожалуйста, в комментариях.
  */
